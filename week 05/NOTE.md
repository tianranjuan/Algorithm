# 再次强调

1. 不要人肉递归，下象棋推演多几步不记得棋盘的样子太真实；
2. 找最近的重复子问题，面试环境下一般难度也就在 3-40 行以内，看似复杂人题目一定会有重复性；
3. 数学归纳法。

# 动态规划 dynamic programming

中文翻译的玄学行，programming 被翻译成规划，但是也可以理解为推导，所以也可以是"动态推导"这样的角度来理解。

本质上还是解决递归或分治问题，但是其对递归和分治的优化在于递归过程中持续寻找最优子问题来寻求最优解。

**wiki 上的定义**

wiki 上对 dp 的定义上有一个重点是：

```
simplifying complicated problem by breaking it down into simpler sub-problems.(in a recursive manner)
简化一个复杂问题为简单的子问题（用递归的方式）
```

这其实直接表明了 dp 是需要进行分治的，所以可以看做是分治的进阶版，而非两个无关的算法。

**dp 与分治区别的三个关键地点**

1.  dp 与分治没有本质区别（关键看有没有最优的子结构）
2.  共性： 找到重复子问题
3.  差异：最优子结构、中途可以淘汰掉次优解

**思维方式的转变**

以斐波拉契数列为例

正常写递归的思维是: 计算 fib(6)那么就先计算 fib(5) + fib(4)...依次类推下去，实现递归的编程，这种思维方式为`自顶向下`的方式；

dp 的思维方式是：更类似人脑的习惯，同样计算 fib(6)但是首先从 fib(1) + fib(2) = fib(3)...递推到 fib(6)，这种思维方式为`自底向上`的方式。

可以看出 dp 的思维方式是更符合人类思考问题的习惯的，这也是写 dp 的一个重要思路，即从 0 开始推导，找到重复性，一步一步的推导到后面直到已经完成了计算，那么最后计算的结果一定就是最优解。

> 从上例中也可以得出 dp 真的就是一点一点推导出最优解，所以如果当做"动态推导"来理解是真的毫无违和感，而且更加的形象。

**dp 实现的三个关键点**

1. 最优子结构： opt[n] = best(opt[n-1], opt[n-2]....opt[1])
2. 存储中间结构:opt[i]，存储在计算之外的，而分治的话更多是在递归之内定义
3. 地推公式（转移方程）：即如何解子问题

**MIT五部简单DP法**

1. defind problems 定义子问题
2. guess（part of solution）猜测递推公式
3. relate subproblems solutions 合并子问题
4. recurse & memoize or build dp table -> bottom-up 递归&记忆化 或者 自底向上的构建dp方程
5. save original problem 保存最优解


# 经验

### 两个字符串的变化问题

最后可能总是会转化成二维数组来求解，其中横纵坐标分别各标识一个字符串

> 自顶向下是递归+记忆化
> 自底向上是递推公式计算
