# 三个思维要点

1. 减少人肉递归，即减少对于脑内递归和手写递归状态树
2. 寻找最近重复性，通过重复性，这个是解决复杂问题的根本
3. 数学归纳思维，用归纳思维来推导出重复性

## 重复性

1. 最近重复性：涉及到各种办法，分治、回溯
2. 最优重复性：即为动态规划

## 递归

主要是找到一种`归去来兮`的感觉

**盗梦空间的类比递归结构**

在电影的主线中主角团们进入梦境后，是通过潜入梦境后在每一层梦境里先进行一些任务来逐步的实现其计划的，所以他们都是先进入一层梦境，然后做一些铺垫，铺垫好后，进入到下一层，直到在最深层梦境完成任务后，依次的叫醒团队成员，然后处理一些收尾工作后回到上层梦境，直到最终回到现实世界。

递归的过程就和主角团们的行动非常的类似。

1. 参数的类比： 参数就像主角团队一样，在每一层梦境中都保持状态，比较类似于递归函数这个作用中的全局变量，其中在电影中每次都要把梦的主人带入到下层梦境中，让其扮演一个全新的角色，这个主人在递归中也存在，就是 curr，它负责在当前层中扮演那场戏中的"主角"；
2. 处理当前逻辑的类比：就好比是世界的 copy，每次进入到一层时世界是全新的与外界毫无关联的新世界，处理逻辑部分就类似这样，每次进入到一层新的递归后都当做是新的事务来处理，就和主角团给梦境主人搭建的舞台一样，看似不一样但其实又一样；
3. 终结条件的类比：类似于主角团们每层梦境要完成的任务目标一样，只有完成了当前层的目标才能回到上层梦境，不然就会沉迷在梦境中无法自拔(死递归)
4. 清理当前层状态(可选)：主角团们在回到上一层梦境后，需要对当前层的世界进行一些收尾工作，好让梦境主人也清醒过来并且处理掉一些不合理的地方免得影响到其他梦境，在递归中就是清理掉一些全局的状态，避免一些全局状态带来的错误判断。

**模板**

```js
function fn(n) {
  // terminator condition
  if (n > 10) return n;
  // process current logic
  console.log(n);
  // dill down
  fn(n + 1);
  // clean current level status if needed
}
```

## 分治思想

分治可以认为是一种比较特殊的递归，其思想主要在于把一个大问题，在递归调用时分解为多个子问题，然后在子问题处理完后处理将子问题结果拼装为当前的结果返回。

**与公司/项目类比**

1. 公司有一个项目，派发给了某部门（调用函数）
2. 部门(算法)派发（切割问题）给一个/多个项目经理目标
3. 各个项目经理拆分任务后下发给开发人员
4. 开发人员分解任务后列出计划
5. 最后逐层汇总各自的任务/计划就是该项目的实施过程

**代码模板**

与递归的模板差不多,主要是在处理电气概念 level 逻辑的地方多了拆分和组合子问题的部分

```js
//Javascript
const divide_conquer = (problem, params) => { 
  // recursion terminator 
  if (problem == null) {    process_result    return  }  
  // process current problem 
  // split problem
  subproblems = split_problem(problem, data); 
  // process subproblems
  subresult1 = divide_conquer(subproblem[0], p1); 
  subresult2 = divide_conquer(subproblem[1], p1); 
  subresult3 = divide_conquer(subproblem[2], p1);
  // ... 
  // merge 
  result = process_result(subresult1, subresult2, subresult3) 
  // revert the current level status
}
```

## 回溯

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

# 关于时间复杂度的计算

**非递归**

在群里看到有同学提问，然后看了助教老师的解答以后，根据自己的理解来记录下。

以“按频率排序字符”那个题，分析的思路为

1. 首先对输入（字符串）进行了什么操作？如果是遍历就位 O(n)，两层就是 O(n2)等
2. 此时新开辟了一块空间，是对遍历后的字符建立的“频率表”,频率表的大小为 k
3. 然后对“频率表”进行了建堆操作，此操作的复杂度是 O(n logn),由于是对频率表建堆所以此时这里的 n = k => O(k logk)
4. 最后在根据堆构建一个 ans 字符串，此时的复杂度依然是 n = k => O(k logk)
5. 此时最终的复杂度就是遍历输入：O(n) + 建立堆：O(k logk) + 遍历堆：O(k logk) = O(n + 2k logk)

关于最终的复杂度 O(n + 2k logk)存在一定的解读偏差，如果能证明 n 与 k 同阶那么可以化简为 O(k logk)，否则可以认为 n 不能忽略，所以是 O(n + k logk)，两种结果都不能算错，只能是说理解角度不同。
