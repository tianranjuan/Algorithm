# 字典树

字典树顾名思义就是一个类似于字典的树型结构，又称单词查找树，Trie 树，前缀树，是一种树形结构，是一种哈希树的变种；其核心思想是空间换时间。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

首先回顾一下查字典索引页的方式：每一位字母都是按照 a-z 的顺序进行排列，所以只要是前缀一样的单词就一定会在相同的区间中；

根据这个原理进行字典树逻辑的模拟规则也可以轻易得出：

1. 字典树具有多层，且每一个节点只包含一个字符；
2. 每一层的子节点不能重复
3. 从第一层开始依次代表着字符串的每一位；
4. 前缀相同的字符串在层级路径上也是相同的，即父节点是一致的；
5. 从父节点到某一节点路径上的所有字符连接起来，就是该节点对应的字符串。

> 是一种使用`直接定址法`来实现的特殊的 hash tree

# 并查集

刚看完课有点没整明白。。。

[[Python/C++/Java] 多图详解并查集](https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/)这个题解很棒，结合课上的内容大体上理解了是怎么回事。

# 平衡二叉树--AVL 树和红黑树

参考资料：[维基百科：平衡树](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)

> 二叉搜索树查询操作的复杂度只与树的深度有关与节点个数无关，为 O(log2n)。

由于二叉搜索树的特性，在理想情况下最好树是一个平衡的状态，这样搜索的性能就会保持最好，但是如果一个普通的二叉树是很难保证这一点的，所以就出现了平衡二叉树的概念。

## AVL 树

1. 引入平衡因子：左子树 - 右子树的高度（也可以调换过来右-左），范围在{-1, 0, 1}
2. 通过旋转来进行平衡

**旋转**

分为四种情况：

1. 左旋
2. 右旋
3. 左右旋
4. 右左旋

**左旋**

右右子树的情况下需要使用左旋，具体为

```
  1   平衡因子: 2                  2
   \                            /  \
    2 平衡因子: 1     ======>    1   3
     \                左旋
      3 平衡因子: 0
```

**右旋**

左左子树的情况下需要使用右旋，具体为

```
      3(2)               2
     /                  / \
    2(1)      ======>  1   3
   /         右旋
  1(9)
```

**左右旋**

左右子树的情况下需要使用左右旋，具体为

```
   3(2)               3               2
  /                  /               / \
 1(1)     ======>   2     ======>   1   3
  \         左旋    /        右旋
   2(0)           1
```

**右左旋**

右左子树的情况下需要使用右左旋，具体为

```
   3(2)                3                 2
    \                   \               / \
     1(1)   ======>      2    ======>  1   3
    /         右旋         \     左旋
   2(0)                    1
```

**具有子树的情况如何旋转？**

[leetcode 刷题(十）：树（红黑树，B 树）](https://zhuanlan.zhihu.com/p/63272157) 这个专栏中的动画很生动形象。

**总结**

1. 严格的平衡二叉树
2. 每个节点需要存储一个整型的平衡因子：{-1, 0, 1}
3. 四种旋转操作

> 缺点是存储整型的平衡因子太占用空间，触发平衡的次数会很频繁。

## 红黑树

由于 AVL 树是严格的平衡二叉树，在某些场景下的需求可能子树的高度差的多些也是可以容忍的，比如差 3 层，差 5 层等等，此时就需要引入一些平衡但是触发平衡次数较少的一些树了，比如红黑树。

**红黑树的特性**

1. 并不是严格的平衡二叉树，属于近似平衡的二叉搜索树；
2. 确保任意一个节点的左右子树高度差不超过 2 倍，保证一定的效率。

**红黑树的条件定义**

1. 每个节点要么是红色，要么是黑色；
2. 根节点是黑色；
3. 每个叶子节点（使用 NIL 节点或空节点表示）是黑色；
4. 不能有相邻的两个红色节点；
5. 从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

**关键性质**

1. 不能有相邻的两个红色节点；
2. 从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

这两个性质保证了红黑在近似平衡的状态下，时间复杂度还能在 O(logn)

## AVL 树与红黑树的对比

1. AVL 查询更快，因为是严格的平衡二叉树；
2. 红黑树比 AVL 有更快的插入和删除操作，原因是操作时触发平衡动作比 AVL 少；
3. AVL 使用额外空间更多，最少需要用一个 int，红黑树可以只使用 1 个 bit 来存储状态，在少量节点时差距不明显，但是大量节点时差距会很明显；
4. 读操作多，写操作少的时候，应该选择 AVL 树来实现，常出现在如数据库，微博等场景；
5. 写操作多，读操作少或者读写操作对半时候，应该选择红黑树来实现，常出现在高级语言的库中，比如 java 中的 HashMap 等。

# 位运算

1. 按位或，有一边是 1 则为 1
2. 按位与，有一边是 0 则为 0
3. 按位取反，0->1, 1->0
4. 按位异或，相同为 0，不同为 1

**异或的特点**

1. x^0 = x => 110 ^ 000 = 110
2. x^ (~0) = ~x => 110 ^ 111 = 001
3. x^ (~x) = (~0) => 110 ^ 001 = 111
4. x^x = 0 => 110 ^ 110 = 0

**指定位置的位运算**

1. 将 x 最右边的 n 位清零： x&(~0 << n) => 00110 & (111 << 2) => 110 & 11100 = 00100
2. 获取 x 的第 n 位值（0 或者 1）：(x >> n) & 1 => (110 >> 2) & 001 => 001 & 001 = 1
3. 获取 x 的第 n 位的幂值：x & (1 << n) => 110 & (001 << 2) => 110 & 100 = 100
4. 仅将第 n 位置为 1： x | (1 << n )
5. 仅将第 n 位置为 0： x & (~1 << n )

**实战例子**

1. 判断奇偶： (x & 1) == 1 ? "奇数" : "偶数"
2. x >> 1 => x / 2
3. x = x & (x - 1) 清零最低为的 1 => 110 & (110 - 1) = 110 & 101 = 100 = 4;
4. x & -x 获取最低为的 1
5. x & ~x = 0 => 110 & 001 = 000 = 0
