# 数组在删除和插入时的复杂度

**插入**

最好O(1)即插入在最后，最坏O(n)即插入在最前。

**删除**

最好O(1)即删除在最后，最坏O(n)即删除在最前。

**随机访问**

O(1)通过内存管理器直接访问到对应的元素即可。


每次插入和删除时都将影响`size-index`个元素。


> 在修改和添加操作比较频繁的情况下链表可以作为数组的替代。


# 链表在删除和插入时的复杂度

**插入**

O(1)修改前驱节点的next指针和插入节点的next指针即可。

**删除**

O(1)修改前驱节点的next指针即可。


每次插入和删除时都将只影响前驱和当前节点两个元素。

**访问头尾元素**

O(1)，直接取第一个和最后一个节点即可。

**随机访问指定位元素**

O(n)需要遍历整个链表才能知道目标元素在哪里。

> 如果是双向链表则会多影响一个后续节点。

# 跳表

诞生于1989年，是一种基于链表的一种特殊的链表，对于链表O(n)的复杂度而言有更高的查询效率，对标二叉查找树，其插入/删除/搜索的复杂度均是O(log n)

**!!使用条件**

链表中数据有序的情况下才能使用跳表。

**思想**

1.升维

将以为数据结构升为二维数据结构，通过二维数据结构存储更多的信息。

2.空间换时间

通过增加索引链表的方式换取运行时的效率。


**优点**

原理简单、容易实现、方便扩展、效率高，在比较热门的项目中会使用其来代替平衡树，如Redis

**原理**

在原始的链表基础上`增加一层(或多层)的索引`，索引同样是一个链表，其内容为以N为步长从原始链表中提取对应的节点

![n=2时(每两个节点取一个)的索引示意](https://upload-images.jianshu.io/upload_images/944288-410008cc643f0248.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
<center>n=2时(每两个节点取一个)的索引示意</center>

同样的可以`对索引建立索引`来检索速度，即对`一级索引`建立索引形成`二级索引`

![2层索引示意](https://upload-images.jianshu.io/upload_images/944288-d5aa2836a06cd6e6.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
<center>2层索引示意</center>

**效率**

跳表在查询时先从高层索引检索找到第一个大于`target`的节点t，然后降低一层索引并从`t-1`节点处开始检索找到第一个大于`target`的节点`t'`，再次降低索引层级，并重复以上步骤，直到在原始链表中找到对应元素。

> 也有可能在原始链表中找不到target节点，此时证明链表中不存在该节点。


![检索示意](https://upload-images.jianshu.io/upload_images/944288-e817e18a340a1b3d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
<center>检索示意</center>


所以可以得出对于原始链表随机访问元素时需要遍历全部节点的操作，如果一个链表有 n 个结点，如果每两个结点抽取出一个结点建立索引的话，那么第一级索引的结点数大约就是 n/2，第二级索引的结点数大约为 n/4，以此类推第 m 级索引的节点数大约为 n/(2^m)。

假如一共有 m 级索引，第 m 级的结点数为两个，通过上边我们找到的规律，那么得出 n/(2^m)=2，从而求得 m=log(n)-1。如果加上原始链表，那么整个跳表的高度就是 log(n)。我们在查询跳表的时候，如果每一层都需要遍历 k 个结点，那么最终的时间复杂度就为 O(k*log(n))，忽略常数为O(log n)。

**空间复杂度**

跳表较之链表引入了新的链表来当做索引，且假设没层索引都是每两个结点抽取出一个结点建立索引的话，那么每层索引的节点数为：n/2+n/4+n/8…+8+4+2，最后总是收敛的，所以其空间复杂度为O(n)。

想要降低跳表所占的空间可以通过抽取点的步长，如每3个点或5个点抽取一个索引节点。

**插入和删除**

链表本身在插入和删除时的复杂度为O(n)，而使用跳表时，由于在插入和删除时要额外的维护一下所有的索引，所以其复杂度会变成O(log n)。

# 



# 一语点醒梦中人

**如何推导出算法的思路？**

通过几次简单的情况去寻找问题中的规律，规律不是硬看出来的，而是应该去找到最近的重复子问题，那么如何寻找最近重复子问题呢？私以为应该是在简单的推演了几次结果后，再次推演的时候去找本次结果与上一次结果的关系，距离<爬楼梯>问题中，在第3次推演的时候，应该问出：到达第3级台阶的上一步应该停留在哪里？拥有几种情况？所以在题目限定的<一次只能走1或2个台阶>时能够顺利到达第3级的状态只有处于第1级台阶或第2级台阶，所以如何到达第3级台阶的问题就变成了，如何到达第1级台阶和第2级台阶，依次推广下去，最终得到`f(n) = f(n - 1) + f(n - 2)`的通项公式。

**这种思想有什么用？**

从前看到leetcode也好，一些个算法也好，总是看不懂为什么就从`1+1`变成了看不懂的样子，如果把视角切换到这种思想来看待问题，那么可以说看懂了`重复子问题`部分的说明，那么也基本可以认为是打开了尴尬的局面了，对于目前的我来说是`忽如一夜春风来`也不足过。



# 参考

- [1] [链表的实现模型](https://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/)